

=================
자료구조의 주요 주제
=================

(1)
 - 리스트
 - 트리
 - 그래프

(2)
 - 정렬과 탐색

(3)
 - 스택, 큐, 해쉬 
=================


4장 스택

스택의 정의 (by 추상데이터타입-ADT)

 - is_empty() : 스택이 비어있나요? 예(1), 아니오(0) 
 - is_full()  : 스택이 모두 차있나요?
 - push(원소) : 스택에 원소를 추가
 - 원소 <- pop() : 스택에서 원소를 빼오기
 - peek() : 스택top의 원소를 읽어오기 (pop은 하지 않고)


스택
 - 한쪽으로만 넣고 빼는 구조
 - LIFO (last-in fist-out) 후입 선출 (나중에 넣은 원소를 먼저 꺼낸다.)

 - history를 가지고 있는 구조

스택을 사용하는 Pseudo code


(1) 입력한 원소의 순서를 뒤집기 (reverse)  (참고: 교재 프로그램 4.1, P.110~111)

      입력: 예를 들어, 5, 2, 8, 7, 9 
      출력: 예를 들어, 9, 7, 8, 2, 5 

      알고리즘:

       1.  입력이 끝날때까지 반복
            1-1. 입력 받기
            1-2. 입력 받은 숫자를 스택에 push

       2.  스택이 완전히 빌 때까지 반복
            2-1. 스택에서 pop한 다음 그 원소를 출력 


stack <- []

// 입력 시작

  push(5)

stack <- [5]

  push(2)

stack <- [2, 5]    // 왼쪽이 top!!!

  push(8)
  
stack <- [8, 2, 5]    // 왼쪽이 top!!!

  push(7)

stack <- [7, 8, 2, 5]    // 왼쪽이 top!!!

  push(9)

stack <- [9, 7, 8, 2, 5]    // 왼쪽이 top!!!

// 입력 끝

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9

stack <- [7, 8, 2, 5]

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9 7

stack <- [8, 2, 5]

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9 7 8

stack <- [2, 5]

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9 7 8 2

stack <- [5]

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9 7 8 2 5

stack <- []

 is_empty()   // true!!!


(2) 괄호 매칭 검사하기! (참고: 교재 P119~)


 [ ] : 대괄호
 { } : 중괄호
 ( ) : 소괄호


 [ ( ] )   ===> (X)
 [ ( ) ]   ===> (O)


 예시
   입력: '[', '(', ']', ')'  ===> 출력: X
   입력: '[', '(', ')', ']'  ===> 출력: O


 알고리즘:

  입력: '[', '(', '{', ']', ')', '}' 6개의 문자들로 이뤄진 임의의 문자열!
  출력: 괄호 매칭 검사 결과 - O, X  
      
  1.  입력이 끝날때까지 반복
      1-1. 입력 받기
      1-2. 입력이 열린 괄호이면 스택에 push   [, {, ( 중 하나
           입력이 닫힌 괄호이면
              스택이 비어있으면, X!!
	      
	      스택이 비어있지 않으면,
                 입력이 ]이면
		     스택 top이 [이면, pop()
	             스택 top이 [이 아니면 X!!
			  
                 입력이 }이면
                     스택 top이 {이면, pop()
                     스택 top이 {이 아니면, X!!
		     
                 입력이 )이면
	             스택 top이 (이면, pop()
                     스택 top이 (이 아니면, X!!


[연습문제]
 위 알고리즘에서 고려하지 않은 빠진 경우???
 ==> 정답 진성호!!!

   stack <- [ '(', ...  ]
   입력 ')'


   stack <- [ '(', ...  ]
   입력 ']'


(3) 후위표기식을 (스택을 사용하여) 계산 (P.124)


후위표기식(postfix expressions) 예: 8 2 / 3 - 3 2 * +

- 진성호

후위표기식 계산 알고리즘

 입력: 후위표기식 
 출력: 계산 결과값
 절차:

  1. 입력이 끝날 때까지 반복
      입력 받기
        입력이 숫자이면 (피연산자이면)
	  push(입력)
	  
	입력이 연산자이면 (+, -, *, /)
	  두번째 피연산자 <- pop() // 오류: 첫번째 피연산자 <- pop()
	  첫번째 피연산자 <- pop() // 오류: 두번째 피연산자 <- pop()
	  
	  첫번째 피연산자 (연산) 두번째 피연산자를 계산하여 그 결과를 얻음
	  
	  push( 결과 )

  2. 스택 top에 계산 결과를 peek()해서 출력


(연습문제)
  - 위의 알고리즘에서 스택과 관련한 미묘한 오류가 있습니다. 무엇일까요?

이현기!

  - (Skip) 중위 표기수식을 후위표기 수식으로 바꾸는 방법 ==> 나중에 tree를 배운 다음

(4) 함수 호출에서 돌아갈(return) 위치를 알기 위해서 스택을 사용합니다.

함수호출과 리턴
 - 프로그램을 시작하기 전에는 비어있는 스택
 
 - 함수를 호출할 때마다 돌아올 주소를 스택에 push()
 
 - return문으로 돌아올 때 스택 top에 있는 주소로 돌아갑니다.
   동시에 pop()을 합니다.

// stack0: empty!!
// main을 호출

 main() {     // stack1: [ 운영체제 주소 ] 

   ...
              // stack2: [ L1, 운영체제 주소 ]
   f();      

 L1: // 라벨
              // stack3: [ 운영체제 주소 ]

   ...

              // stack4: [L2,  운영체제 주소 ]
   f();

 L2:  // 라벨
              // stack5: [ 운영체제 주소 ]

   ...

 }

 f() {

   ...

  return;  // Q. L1과 L2 중 어느 곳으로 돌아갈까요?
           // A. stack2의 경우 스택 top은 L1 !! 따라서 L1으로 돌아갑니다. 물론 pop()도 하고.!
           //    stack4의 경우 스택 top은 L2 !! 따라서 L2로 돌아갑니다. 물론 pop()도 하고.!
 }

[연습문제] 함수 호출을 goto문과 스택을 사용해서 흉내내보시라!

int fib(int n) {

L1:
    if ( n==1 || n==2 ) return 1;
    else {
    	 int a, b;

         a = fib(n-1);
L2:

	 b = fib(n-2);
L3:

         return a+b;
    }
}

===> Goto문과 스택을 사용해서 rewriting 해보세요 !
     함수 호출을 사용하면 안됨!
     점프하고 싶은/필요한 위치에 마음대로 라벨을 추가하세요. 
     필요한 코드는 추가하셔도 됩니다.


(5) 미로 탐색 문제 (P.135, Sec.4.6)

 스택을 이용해서 체계적으로 미로를 탐색하는 알고리즘
 (체계적 ==> 이미 지나간 길을 반복해서 또 지나가지 않는다!
       ==> 그러려면 지나온 길을 기억해야지요!
       ==> 그래서 스택이 유용합니다.


 현재 위치에서 갈 수 있는 방향, 동/서/남/북

  - 동/서/남/북 중에서 블록을 막힌 길은 안간다
  - 동/서/남/북 중에서 내가 방금 전에 온 방향을 거슬러 올라가지 않는다!
  - 그리고 남은 모든 방향들을 가본다! (기본적인 아이디어)

  알고리즘
    입력: 미로, 시작 위치(x1,y1), 끝 위치(x2,y2)
    출력: 미로 탐색 길
    절차:

      현재 위치 <- (x1, y1)
      스택 <- empty stack

  1.  현재 위치일 끝 위치(x2, y2)가 될 때까지 반복

    1-1 현재 위치에서 가능한 방향
       1-1-1 동:  블록으로 막혀있거나 방금 전에 온 위치(스택 top)이면 skip
                그렇지 않으면 현재 위치를 push()
	        현재 위치를 동쪽으로 이동  (x를 1증가!)
       1-1-2 서:  블록으로 막혀있거나 방금 전에 온 위치(스택 top)이면 skip
                그렇지 않으면 현재 위치를 push()
	        현재 위치를 서쪽으로 이동  (x를 1감소!)
       
       1-1-3 남:  블록으로 막혀있거나 방금 전에 온 위치(스택 top)이면 skip
                그렇지 않으면 현재 위치를 push()
	        현재 위치를 남쪽으로 이동  (y를 1증가!)
		
       1-1-4 북:  블록으로 막혀있거나 방금 전에 온 위치(스택 top)이면 skip
                그렇지 않으면 현재 위치를 push()
	        현재 위치를 남쪽으로 이동  (y를 1감소!)
		
    1-2
        현재 위치를 스택 top에 저장된 위치로 설정. 스택을 pop().
     
[연습문제]
 - 현재 위치에서 끝 위치까지 길이 없는 미로가 입력으로 들어왔을 때
   위 알고리즘은 어떤 방식으로 결과를 낼까요?

   이 문제를 해결하려면 어떻게 알고리즘을 수정해야할까요?

(10/6) 스택 구현 (5가지 연산)

스택의 원소 구현
 - 임의의 자료형!!
 - int, char, string, 구조체, ...
 - C언어: 임의의 자료형을 표현하기 편리하지 않은 프로그래밍언어
 - Java언어: 제네릭스(generics) 특징
     : Stack<E>    E라는 자리에 임의의 타입을 놓을 수 있음
       Stack<Integer>
       Stack<String>
       Stack< ... 원하는 자료형 ... >

//////////////////////////////
// 배열을 가지고 스택을 구현하는 방법
//////////////////////////////

#define MAX_STACK_SIZE 100

int stack[MAX_STACK_SIZE]; // element stack[MAX_STACK_SIZE];
int top = -1; // 스택 맨 위의 원소의 배열 첨자! 초기값은 -1 !!

스택 연산 구현

int is_empty() {
  return (top == -1); 
}

int is_full() {
  return (top == MAX_STACK_SIZE-1);
}

void push(int item) {

  // (1) 꽉 차있는 스택
  if( is_full() ) {
      // 에러!!
      fprintf(stderr, "error: push onto the full stack\n");
      return;
  }
  
  // (2) 비어있는 스택
  // (3) 어느 정도 차있는 스택
  else {
   //    |  |     top+1
   //    +--+
   //    |* |  <- top
   //    +--+
   //    ....

   stack[top+1] = item;
   top = top+1;

   // stack[++top] = item; 

   //    | item |  <-top+1
   //    +------+
   //    |*     |  
   //    +------+
   //    ....
  }
}

int pop() {
   // (1) 스택이 비어있는 경우
   if ( is_empty() ) {
      // 에러!!
      fprintf(stderr, "error: pop from the empty stack\n");
      return;
   }
   
   // (2) 스택이 비어있지 않는 경우
   else {
   	int ret_item;

	ret_item = stack[top];
        top = top - 1;

        return ret_item;

	// return stack[top--];  (X) !!!
   }
}

int peek() {
   // (1) 스택이 비어있는 경우
   if ( is_empty() ) {
      // 에러!!
      fprintf(stderr, "error: peek from the empty stack\n");
      return;
   }
   
   // (2) 스택이 비어있지 않는 경우
   else {
        return stack[top];
   }
}

