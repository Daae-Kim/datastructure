
=========
9/3일 강의
=========

소스프로그램을 작성하여 실행 파일을 만드는 과정
  소스프로그램  ==컴파일(compile)==>  목적프로그램  ==링킹(linking)==> 실행 파일

C프로그래밍
 - Microsoft Visual studio (윈도우즈)
    : 컴파일하는 방법 : IDE안에서 F5키를 누르면 컴파일!
    : 실행 파일 이름 (예: hello.exe)
 - clang/gcc (리눅스)
    : $ clang hello.c      cf. clang : 컴파일러 (compiler)
    : $ clang hello.c -o hello
    : 실행 파일 이름 (예: a.out)



변수

while 반복문

자료형
 - int, char, float, double
   정수   문자   실수     실수
   컴퓨터마다 자료형이 표현하는 바이크 크기가 다르지만
   일반적으로

   int =>32bit (4byte)
   char => 8bit (1byte)
   float => 32bit (4byte)
   double => 64bit (4byte) 

 - Guideline: 실수를 표현할 상황에서 double을 사용하세요. float 사용하지 마세요!!

/////////////////////////////////////
// 0부터 300까지 20씩 증가하면서 화씨를 섭씨로 변환
/////////////////////////////////////

  fahr = lower; // 초기 
  while (fahr <= upper)  {  // 반복 조건
    // 화씨 fahr을 섭씨 upper로 변환
    
    fahr = fahr + step;  // 다음 값
  }

/////////////////////////////////////
// while 루프를 for루프로 바꾸어 작성하기!
/////////////////////////////////////
  
  for ( fahr = lower ;  fahr <= upper ;  fahr = fahr + step ) {
    // 화씨 fahr을 섭씨 upper로 변환

  }

////////////////////////////
// 한 문자씩 입력받아 할 일을 하기
////////////////////////////
  c = getchar();  // 문자 1개를 키보드로부터 입력받는 라이브러리 함수
  while (c != EOF) {

    // 할 일 작성 하기
    
    c = getchar();
  }


 [참고] getchar() : 키보드로부터 1문자 입력 받는 함수
       putchar(ch) : 화면에 1문자 ch를 출력하는 함수


(*) 강진호 박지혜 탁민경 조민주 이수현

===========
9/8(화) 강의
===========


(*) Emacs (편집기, editor)


///////////////////////////////////////////////
// 문자 갯수, 라인 갯수, 단어 갯수를 세는 프로그램을 작성
///////////////////////////////////////////////

cf. 리눅스 명령어: wc 

// 문자 갯수

  int c;  // vs. char c;
  int nc; // number of chars.

  nc = 0;
  
  c = getchar();  // 문자 1개를 키보드로부터 입력받는 라이브러리 함수
  
  while (c != EOF) {
   // 새로운 문자가 들어왔구나!
    nc = nc + 1;
    
    c = getchar();
  }

  printf("nc: %d\n", nc);
  
// 라인 갯수

  int c;  // vs. char c;
  int nl; // number of lines

  nl = 0;
  
  c = getchar();  // 문자 1개를 키보드로부터 입력받는 라이브러리 함수
  
  while (c != EOF) {
    // 새로운 문자가 들어왔구나!

    // c == '\n' 이면 새로운 줄이 시작되었구나!
    if (c == '\n') {
      nl = nl + 1;
    }
    
    c = getchar();
  }

  printf("nl: %d\n", nl);

// 단어 갯수


state==OUT 인 상태에서 공백이 아닌 문자 'c'를 입력하면 state 를 IN을 바꿈!

   ' '  c     honnam' 'national' 'university'\n'
   OUT  IN




// 배열

int ndigt[10];

ndigit[0] ~ ndigit[9]


// 함수

(1) 함수 선언 
(2) 함수 호출
(3) 함수 정의


==========
9/10일 강의
==========

// 구조체



// REMIND:

// 타입 <==> 자료형

// 1. 기본 타입
//   int, char, double (, float)

// 2. 배열 타입
//   int a[10];   a는 변수!

//   int[10]  정수 원소를 10개 가지고 있는 배열 타입
//   char[10] 문자 원소를 10개 가지고 있는 배열 타입
//   double[10] 문자 원소를 10개 가지고 있는 배열 타입
//   ...

// 3. 구조체 타입.  이것은 타입입니다. 변수가 아닙니다!!
struct StudentInfo {
  char name[10];  // 이름: char[10] 배열 타입
  int id;         // 학번: int 타입
};

// 구조체 타입을 사용한 변수 선언!
// struct StudentInfo s;     // s라는 변수가 해당 구조체 타입을 갖습니다.

// s.name[0] = 'C';
// s.name[1] = 'h';
// s.name[2] = 'o';
// s.name[3] = 'i';
// s.name[4] = '\0';  // 문자열 마지막에 널 문자 '\0'

// s.id = 1234567;

// . ==> 구조체 멤버쉽 연산자 !!!


배열 타입과 구조체 타입의 비슷한 점
 - 여러 원소를 포함하는 타입이다!

배열 타입과 구조체 타입의 다른 점
 - 배열 타입은 모든 원소가 같은 타입이다!
 - 구조체 타입은 각 원소가 다른 타입을 갖을 수 있다!


함수 인자 전달 방식 (값으로 전달하는 방식, call-by-value)

- 기본 타입: int, char, double (, float)
  ===> 값을 복사해서 인자를 전달하는 방식

- 배열 타입: 
  ===> 배열 실체를 인자로 전달하는 방식

- 구조체 타입: 
  ===> 구조체 값을 복사해서 인자를 전달하는 방식

- 포인터 타입:
  ===> 포인터 값을 복사해서 인자를 전달하는 방식 


============================
재귀 함수(recursive function)
============================

(1) sum을 재귀함수
 - sum -> sum

(2) f,g를 둘 다 재귀함수
 - f -> g
 - g -> f

int sum(int n) {
    if(n >=0) return 0
    else n + sum(n-1);
}

재귀 함수를 작성하거나 이해하는 Key Idea
 - 재귀 함수 작성과 귀납법으로 증명하는 과정이 동일하다!!!


귀납법으로 명제 P(n)을 증명

 P(n) : Sigma_i=1,n i = n(n+1)/2

 (정수 n>=1)


n=1: (왼쪽)  Sigma_i=1,n = 1    (n이 1)

     (오른쪽) 1(1+1)/2    = 1

     증명 끝!

n=k+1:

     n=k일 때 P(n)이 참이라고 가정

       - Sigma_i=1,k   =    k(k+1)/2

     (요령: n=k일 참이라고 가정하는 명제를 활용하여
           n=k+1일때 명제를 증명!!!)


     (왼쪽)   Sigma_i=1,k+1
           = (Sigma_i=1,k)  +  (k+1)
	   = k(k+1)/2       +  (k+1)   by n=k일 때 가정
	   = (k+1) (k/2     +   1)
	   = (k+1)(k+2)/2
           = (오른쪽)


=========
9/15일 강의
=========


==============
포인터(pointer)
==============

C언어의 가장  큰 특징!


자료형
 - 기본형: int, char, double (, float)
 - 배열형: int[10], char[10], double[10] (, float[10])   (e.g., int arr[10])
 - 구조체형: struct S

    e.g., 배열형하고 구조체형하고 조합
           : struct S s_arr[10];

 - 포인터형: T*

   T가 뭐냐?
    - 기본형
    - 구조체형
    - 배열형
    - 임의의 자료형

 - T*    (T: 기본형)
 
   포인터형   포인터 변수 
   int*    p_i;
   char*   p_c;
   double* p_d;
   float*  p_f;

 - 변수: 값을 담는 박스
   +----+
   |    |
   +----+

 - 변수 안에 담는 값의 자료형이 무엇이냐? 답은 변수의 자료형!

   int x;
 
   x:
   +-----+
   | 123 |
   +-----+
   
   char c;

   x:
   +-----+
   | 'Z' |
   +-----+

   int* p_i;

   p_i:
   +-----+
   | 주소 |   이 박스 안에 무엇이 들어가야 할까요? 
   +-----+    - 포인터형의 값: 주소 (60점 답안. 100점 답안이 아닙니다!)
                             주소 그리고 그 주소를 따라가면 int의 값이 나옵니다!

   char* p_c;

   p_c:
   +------+
   | 주소  |  이 박스 안에 무엇이 들어가야 할까요? 
   +------+    - 포인터형의 값: 주소 (60점 답안. 100점 답안이 아닙니다!)
                             주소 그리고 그 주소를 따라가면 char의 값이 나옵니다!


   T* p_t;

   p_t:
   +------+
   | 주소  |  이 박스 안에 무엇이 들어가야 할까요? 
   +------+    - 포인터형의 값: 주소 (60점 답안. 100점 답안이 아닙니다!)
                             주소 그리고 그 주소를 따라가면 자료형 T의 값이 나옵니다!
   

   char** pp_c;      char**  ===> (char*) *  ===> T *   (where T: char*)

   pp_c:
   +-----+
   | 주소  |  이 박스 안에 무엇이 들어가야 할까요? 
   +-----+    - 포인터형의 값: 주소 (60점 답안. 100점 답안이 아닙니다!)
                             주소 그리고 그 주소를 따라가면 char* 자료형의 값이 나옵니다!

 - 주소연산자 &  (amphersand, 앰퍼샌드)
 
   int x=123;
   char c='A';
   doubld d=3.14;

   int* p_i;
   char* p_c;
   char** pp_c;

   p_i = & x;    // int 변수 x의 주소를 p_i (박스)에 저장한다!

   p_i = & c;    // [틀립니다!!!]
   
   x:
   +-----+
   | 123 |
   +-----+
   
   p_i:
   +-----+
   | &x  |   &x 대신에 화살표로 대체해서 그리는 것도 좋은 설명
   +-----+    : p_i 박스 안에서 출발하여 x 박스를 가리키는 화살표


   pp_c = & p_c ;   /// char* p_c 이기 때문에!!!  pp_c의 주소는 char*를 가리켜야 합니다.


[포인터에 관한 연산자 3가지]

 - (자료형)
     * 연산자  (e.g,  int* p_i, char**pp_c )
 
 - (변수에 대한 연산자)
     * 연산자 (참조연산자)    e.g,   *p_i    // x (박스)에 담긴 주소를 따라가서 찾은 값!
                                   *pp_c   // pp_c (박스)에 담긴 주소를 따라가서 찾은 값!
     
     & 연산자 (주소연산자)    e.g.,  &c      // c의 주소
                                   &x      // x의 주소
				   &p_i    // p_i의 주소
				   &pp_c   // pp_c의 주소


- 배열과 포인터는 친한 사촌!
  (배열과 포인터를 형태를 바꿔서 사용하는 것이 가능하다)

  int arr[10];

    (OK) 변수 arr의 타입은 배열 타입 int[10]  !!
    (OK) 변수 arr의 타입은 int*              !!
    
         더 정확히 설명하자면 int*라기 보다 const int* 포인터형입니다
          : const가 자료형 앞에 들어가면 해당 자료형의 변수 값을 못바꾼다!
	  : 따라서 const int* 자료형의 변수를 선언하면 해당 변수에 있는 주소값을 못바꾼다!
	 
  int* p;


  p = arr;   // 아주 적법한 C언어 문장입니다!!
  
             // 대입문/할당문을 사용하려면
	     //    왼쪽의 자료형과 오른쪽의 자료형이 같아야 합니다!!


- 식 E      (e.g., z, p, 1 + 2,  x - 3, ...)

  식 E의 자료형 T   ===>    E  :   T

    e.g.   x : int
           p_c : char*


[포인터 자료형을 이해하는 규칙]
   (1) 만일 E : T이면 &E : T*이다.   [주소연산자에 관한 규칙]

     예)   x : int  ===>    &x : int*
          c : char ===>    &c : char*
          p_i : int*   ===>  &p_i : int**
	  pp_c : char**  ===> & pp_c : char*** 

   (2) 만일 E : T*  이면 *E : T이다.   [참조연산자에 관한 규칙]

     예)   p_i : int*  ===> *p_i : int    !!
          pp_c : char**  ===> *pp_c : char* !!


int main(int argc, char* argv[]) {
 // ...
}

char* argv[] 를 분석!!!


(argv의 타입)
 - argv :  (char*)의 배열 타입
      ===> (char*) [] 
      ===> (char*) *
      ===> char**

  argv는 박스!
  그 박스 안에 어떤 것이 들어가 있지요? 주소! 그 주소가 가리키는 박스 안을 보면 char* 주소!


[C언어 원칙: 왼쪽 자료형과 오른쪽 자료형은 동일해야 대입문/할당문을 사용할 수 있다!]

   int x=123;
   char c='A';
   doubld d=3.14;

   int* p_i;
   char* p_c;
   char** pp_c;

   p_i = & x;    // [왜 OK?]
                 // p_i : int*                                 왼쪽 int* 
		 // x : int,  따라서 x : int ===> &x : int* !!  오른쪽 int*  같네!!!
                 //          

   p_i = & c;    // [왜 틀립니꽈?]
                 // p_i : int*                                 왼쪽 int*
		 // c : char ===> &c : char* !!               오른쪽 char*  다르네!!!

   x = *p_i;     // [왜 OK?]
                 // x : int                        왼쪽: int
		 // p_i : int*   ===> *p_i : int  오른쪽: int   같네!!!

   pp_c = &p_c;  // [왜 OK?]
                 // pp_c : char**
		 // p_c : char*  ===> &p_c : (char*) * ===> &p_c : char**  왼쪽 오른쪽 char**로 같네!!

   p_c  = *pp_c; // [왜 OK?]
                 // pp_c : char** ===> *pp_c : char*
		 // p_c : char*                        왼쪽 오른쪽 char*로 같네!!


- 구조체

  strcut S {
   int id;
   char name[10];
   };

  struct S s1;
  struct S s2;

  s1.id = 123;
  strcpy(s1.name, "Choi Kwanghoon");


  struct S*  ps;


  ps = & s1;    // [왜 OK?]
                //  ps : (struct S)* == struct S*  !!!
		//  s1 : struct S  ===> &s1 : (struct S)*
		// 왼쪽과 오른쪽이 (struct S)*으로 같네!!!

  s2 = *ps;     // [연습문제]
                // s2 :  ???
		// ps : ???   ===>  *ps : ???
		// 왼쪽과 오른쪽이 ??? 으로 같네!!!

[구조체 포인터 사용할 때 주의사항]
 - *ps.id    (X: 이렇게 작성하면 안됩니다)
 - (*ps).id  (O: 불편해! 괄호를 반드시 붙여주어야 합니다.)
 - ps->id    (O: 편리해! 괄호를 붙이는 것이 불편하니까 ps->id라고 작성하면 (*ps).id와 같은 식으로 간주합니다!!!)
