

자료구조 개요 (교재 1장)

- 용어

   : 알고리즘과 자료구조
      (cf. 추상자료형 -abstract data type )
   
   : 시간/공간 복잡도 (time/space complexity)
     ==> 빅오 표기법  [vs. 몇 초 걸려, 몇 바이트 사용해?]


1. 알고리즘
  : 간단히 설명하면, 절차!

  : 조금 복잡하게 설명하면,
    - 입력, 출력, 객관적 절차, 항상 종료


2. 자료구조

알고리즘에서 다루는 자료구조는 보통 추상데이터타입으로 간주해서 기술한다.

 - 추상데이터타입은 해당 타입의 값을 다룰 수 있는 연산들로 정의된 데이터 타입이다!


자료구조의 예: 스택

       +----+----+----+---
막힘   | 3   | 1  | 2  |      <=== 데이터를 추가하고 뺄 수 있는 방향
       +----+----+----+---


스택 자료구조를 정의하는 3가지 연산 (추상 자료형)
 - push( elem )
 - elem <- pop()
 - top()

3. 시간/공간 복잡도

  - 빅오 표기법
    : 기본 아이디어 (informal definition)
         주어진 입력의 크기 n에 대해
	 연산이 수행된 횟수 f(n)을 구한 다음
	 f(n)에서 가장 큰 차수만 고려하는 분석 방법/표기법

    4n^2 - 3n + 7
      ===>  4n^2 - 3n^1 + 7n^0
      ===> O(n^2)  !!!
           "Order of n^2"

    : 빅오 표기법의 목적

       입력 크기가 증가함에 따라 복잡도의 증가 추이를 살피는데 유용함!!


========================================================================

[9/22(화)]

시간복잡도

 - T(n) : 주어진 프로그램/함수가 입력 크기 n에 대하여 실행 시간

   예) T(n) = 4n^2 - 3n + 7

빅오 표기법의 정의

 (1)     T(n)이 O( f(n) )이다.
   또는 T(n) ∈ O( f(n) ).     ===> O( f(n) ) 함수들의 집합!

 - Def. T(n) ∈ O( f(n) ):
        ∃c, ∃n₀, T(n) ≤ c f(n) for all n ≥ n₀ 

 - 예) 앞에서 T(n) = 4n² - 3n + 7   ∈  O(n²)  라고 설명을 했습니다.
      이 설명을 정의에 맞추어서 살펴보겠습니.다

      4n² - 3n + 7  ≤ c n²  for all n ≥ n₀ 인 c와 n₀가 존재합니까?

      c=11, n₀=1

      4n² - 3n + 7  ≤ 11 n²
                    = 

      -3n + 7  ≤ 7n²     n≥n₀   (n₀=1)  자명하지요!

      따라서 T(n) ≤ cf(n) for all n≥n₀ 인 c와 n₀를 찾았습니다!!!!

      이렇게 찾으면 T(n) ∈ O(f(n)) 라고 합니다!!


 - 예) T(n) = 3n³ + 2n² ∈ O(n³)

      3n³ + 2n² ≤ cn³ for all n≥n₀ 를 만족하는 c와 n₀?

      c=5, n₀=1 !!



 - T(n) ∈ O(f(n)) ===> f(n)의 증가율이 T(n)의 증가율의 상한(upper bound)이다!

    cf. 증가율: growth rate


     예) T(n) = 3n³ + 2n² ∈ O(n³)라고 이야기할 수 있지만,

         T(n) = 3n³ + 2n² ∈ O(n⁴)라고 이야기해도 됩니다!


         왜냐하면, 3n³ + 2n² ≤ c₁ n⁴  for all n≥n₁

                c₁ = 5, n₁ = 1이면 성립하지요!


 (2)      T(n)이 Ω( f(n) )이다.       오메가!
     또는  T(n) ∈ Ω( f(n) )

           ===> f(n)은 T(n)의 하한(lower bound)이다!!

    Def. T(n) ∈ Ω( f(n) )

          ∃c,n₀,  T(n) ≥ cf(n)  for all n≥n₀ 
     
     예) T(n) = n³ + 2n² ∈ Ω( n³ )

        n³ + 2n² ≥ c n³    c=1, n₀=1
	
        n³ + 2n² ≥  n³    for all n≥1


     예) T(n) = n³ + 2n² ∈ Ω( n² ) 


 (3) T(n) ∈ Θ( f(n) )  if and only if T(n) ∈ O( f(n) ) and T(n) ∈ Ω( f(n) )

     cf. 쎄타!



===========================

(참고)
 - 1 ≤ log n ≤ n ≤ nlogn ≤ n² ≤ n³ ≤ 2ⁿ ≤ n!

 - O(1) ≤ O(log n)   잘못된 설명!  (교재 P.30)
 
   O(1) ⊆ O(log n)   보다 정확한 설명!

===========================

The rules for sum & the rules for product

 - 주어진 프로그램의 시간 복잡도를 분석할 때 유용한 기법!


The rules for sum

 - T₁(n) ∈ O(f(n))
   T₂(n) ∈ O(g(n))

   T₁(n) + T₂(n) ∈ O( max( f(n), g(n) ) )

(연습문제) The rules for sum을 O(-)의 정의에 의해 증명하시오

   T₁(n) + T₂(n) ≤ c ( max( f(n), g(n) ) )  for all n≥n₀

   c와 n₀가 무엇인지 보이면 증명 끝!


예)

   (Prg)
    문장1;  ===> O(n²)
    문장2;  ===> O(n)

   (Prg)의 실행시간 복잡도를 구하시요.

    The rules for sum을 이용하여 O ( max(n², n) )을 구하면 됩니다.
    따라서, (Prg)의 실행시간 복잡도는 O(n²) !!

The rules for product 

 - T₁(n) ∈ O(f(n))
   T₂(n) ∈ O(g(n))

   T₁(n) × T₂(n) ∈ O( f(n)g(n) )
    
(연습문제) The rules for product를 O(-)의 정의에 의해 증명하시오

  - 아이디어만 설명


   (Prg)
     for (i=1, ... ) {
        for (j=1, ... ) {
	}
     }

===========================

실제 프로그램의 실행시간 복잡도 분석 사례1

// 버블 정렬
procedure bubble (var A: array[1..n] of integer)
var
  i, j, temp : integer;

  begin
    for i:=1 to n-1 do                     // (1)
    
      for j:=n to i+1 do                   // (2)
      
        if A[j-1] > A[j] then begin        // (3)
	   temp = A[j-1];                  // (4)
	   A[j-1] = A[j];                  // (5)
	   A[j] = temp;                    // (6)
	end
	
      end
      
    end
  end


(*) 입력 크기(배열 원소 갯수 n)가 달라지더라도 (4)를 실행하는 시간은 항상 c로 일정!

(4):  T₄(n) = c₄ ∈ O(1)
(5):  T₅(n) = c₅ ∈ O(1)
(6):  T₆(n) = c₆ ∈ O(1)

(4)+(5)+(6): T₄(n)+T₅(n)+T₆(n) ∈ O( max (1, 1, 1) ) = O(1) 


(*) if문에서 참이면 (4)~(6)을 실행하고, 거짓이면 실행하지 않음.
    상한(upper bound) 실행시간 복잡도를 분석하고 있기 때문에
    최악의 경우, 즉 더 오래 걸리는 경우를 분석함
(3)+(4)~(6):

  (3) T₃(n) = c₃ ∈ O(1)
  (4)~(6): O(1)

  T₃(n) + (T₄(n)+T₅(n)+T₆(n)) ∈ O( max(1, 1) ) = O(1)
  

(1): T₁ = Σ_{i=1,n}  T₂

(2): T₂ = Σ_{j=n,i+1} T₃+T₄+T₅+T₆
        = Σ_{j=n,i+1} c
	= (n-i) × c

따라서,
(1): T₁ = Σ_{i=1,n}  (T₂)
        = Σ_{i=1,n}  ( c(n-i) )
	= c(n-1) + c(n-2) + c(n-3) + ... + c×1 + c×0
	= c × (1부터 n-1까지 합) !!!
	= c x (n-1)(n)/2
	= c/2 n² - c/2 n

정리하자면, 함수 bubble의 실행시간 T(n) = c/2 n² - c/2 n    (cf. n: 입력 배열의 크기)

                            T(n) ∈ O(n²) !!!


실제 프로그램의 실행시간 복잡도 분석 사례2

function fact( n:integer )  integer;
 begin
    if n ≤ 1 then
      return 1;
    else
       return n * fact(n-1);
 end


(연습문제)

  - fact의 실행시간 T(n)을 구하시오.   (cf. n은 인자 n. fact(3) ===> n==3!!)
  - T(n) ∈ O( ???  ) 인지 구하시오.


https://github.com/kwanghoon/datastructure
 - intro/MEMO_intro.txt


(연습문제)
  - 하노이 타워 프로그램의 실행시간 복잡도를 분석하시오!


