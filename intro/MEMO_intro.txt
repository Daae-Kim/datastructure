

자료구조 개요 (교재 1장)

- 용어

   : 알고리즘과 자료구조
      (cf. 추상자료형 -abstract data type )
   
   : 시간/공간 복잡도 (time/space complexity)
     ==> 빅오 표기법  [vs. 몇 초 걸려, 몇 바이트 사용해?]


1. 알고리즘
  : 간단히 설명하면, 절차!

  : 조금 복잡하게 설명하면,
    - 입력, 출력, 객관적 절차, 항상 종료


2. 자료구조

알고리즘에서 다루는 자료구조는 보통 추상데이터타입으로 간주해서 기술한다.

 - 추상데이터타입은 해당 타입의 값을 다룰 수 있는 연산들로 정의된 데이터 타입이다!


자료구조의 예: 스택

       +----+----+----+---
막힘   | 3   | 1  | 2  |      <=== 데이터를 추가하고 뺄 수 있는 방향
       +----+----+----+---


스택 자료구조를 정의하는 3가지 연산 (추상 자료형)
 - push( elem )
 - elem <- pop()
 - top()

3. 시간/공간 복잡도

  - 빅오 표기법
    : 기본 아이디어 (informal definition)
         주어진 입력의 크기 n에 대해
	 연산이 수행된 횟수 f(n)을 구한 다음
	 f(n)에서 가장 큰 차수만 고려하는 분석 방법/표기법

    4n^2 - 3n + 7
      ===>  4n^2 - 3n^1 + 7n^0
      ===> O(n^2)  !!!
           "Order of n^2"

    : 빅오 표기법의 목적

       입력 크기가 증가함에 따라 복잡도의 증가 추이를 살피는데 유용함!!


========================================================================

[9/22(화)]

시간복잡도

 - T(n) : 주어진 프로그램/함수가 입력 크기 n에 대하여 실행 시간

   예) T(n) = 4n^2 - 3n + 7

빅오 표기법의 정의

 (1)     T(n)이 O( f(n) )이다.
   또는 T(n) ∈ O( f(n) ).     ===> O( f(n) ) 함수들의 집합!

 - Def. T(n) ∈ O( f(n) ):    (cf. Order of f(n))
        ∃c, ∃n₀, T(n) ≤ c f(n) for all n ≥ n₀ 

 - 예) 앞에서 T(n) = 4n² - 3n + 7   ∈  O(n²)  라고 설명을 했습니다.
      이 설명을 정의에 맞추어서 살펴보겠습니.다

      4n² - 3n + 7  ≤ c n²  for all n ≥ n₀ 인 c와 n₀가 존재합니까?

      c=11, n₀=1

      4n² - 3n + 7  ≤ 11 n²
                    = 

      -3n + 7  ≤ 7n²     n≥n₀   (n₀=1)  자명하지요!

      따라서 T(n) ≤ cf(n) for all n≥n₀ 인 c와 n₀를 찾았습니다!!!!

      이렇게 찾으면 T(n) ∈ O(f(n)) 라고 합니다!!


 - 예) T(n) = 3n³ + 2n² ∈ O(n³)

      3n³ + 2n² ≤ cn³ for all n≥n₀ 를 만족하는 c와 n₀?

      c=5, n₀=1 !!



 - T(n) ∈ O(f(n)) ===> f(n)의 증가율이 T(n)의 증가율의 상한(upper bound)이다!

    cf. 증가율: growth rate


     예) T(n) = 3n³ + 2n² ∈ O(n³)라고 이야기할 수 있지만,

         T(n) = 3n³ + 2n² ∈ O(n⁴)라고 이야기해도 됩니다!


         왜냐하면, 3n³ + 2n² ≤ c₁ n⁴  for all n≥n₁

                c₁ = 5, n₁ = 1이면 성립하지요!


 (2)      T(n)이 Ω( f(n) )이다.       오메가!
     또는  T(n) ∈ Ω( f(n) )

           ===> f(n)은 T(n)의 하한(lower bound)이다!!

    Def. T(n) ∈ Ω( f(n) )

          ∃c,n₀,  T(n) ≥ cf(n)  for all n≥n₀ 
     
     예) T(n) = n³ + 2n² ∈ Ω( n³ )

        n³ + 2n² ≥ c n³    c=1, n₀=1
	
        n³ + 2n² ≥  n³    for all n≥1


     예) T(n) = n³ + 2n² ∈ Ω( n² ) 


 (3) T(n) ∈ Θ( f(n) )  if and only if T(n) ∈ O( f(n) ) and T(n) ∈ Ω( f(n) )

     cf. 쎄타!



===========================

(참고)
 - 1 ≤ log n ≤ n ≤ nlogn ≤ n² ≤ n³ ≤ 2ⁿ ≤ n!

 - O(1) ≤ O(log n)   잘못된 설명!  (교재 P.30)
 
   O(1) ⊆ O(log n)   보다 정확한 설명!

===========================

The rules for sum & the rules for product

 - 주어진 프로그램의 시간 복잡도를 분석할 때 유용한 기법!


The rules for sum

 - T₁(n) ∈ O(f(n))
   T₂(n) ∈ O(g(n))

   T₁(n) + T₂(n) ∈ O( max( f(n), g(n) ) )

(연습문제) The rules for sum을 O(-)의 정의에 의해 증명하시오

   T₁(n) + T₂(n) ≤ c ( max( f(n), g(n) ) )  for all n≥n₀

   c와 n₀가 무엇인지 보이면 증명 끝!


예)

   (Prg)
    문장1;  ===> O(n²)
    문장2;  ===> O(n)

   (Prg)의 실행시간 복잡도를 구하시요.

    The rules for sum을 이용하여 O ( max(n², n) )을 구하면 됩니다.
    따라서, (Prg)의 실행시간 복잡도는 O(n²) !!

The rules for product 

 - T₁(n) ∈ O(f(n))
   T₂(n) ∈ O(g(n))

   T₁(n) × T₂(n) ∈ O( f(n)g(n) )
    
(연습문제) The rules for product를 O(-)의 정의에 의해 증명하시오

  - 아이디어만 설명


   (Prg)
     for (i=1, ... ) {
        for (j=1, ... ) {
	}
     }

===========================

실제 프로그램의 실행시간 복잡도 분석 사례1

// 버블 정렬
procedure bubble (var A: array[1..n] of integer)
var
  i, j, temp : integer;

  begin
    for i:=1 to n-1 do                     // (1)
    
      for j:=n to i+1 do                   // (2)
      
        if A[j-1] > A[j] then begin        // (3)
	   temp = A[j-1];                  // (4)
	   A[j-1] = A[j];                  // (5)
	   A[j] = temp;                    // (6)
	end
	
      end
      
    end
  end


(*) 입력 크기(배열 원소 갯수 n)가 달라지더라도 (4)를 실행하는 시간은 항상 c로 일정!

(4):  T₄(n) = c₄ 
(5):  T₅(n) = c₅ 
(6):  T₆(n) = c₆ 

(4)+(5)+(6): T₄(n)+T₅(n)+T₆(n) = c₄ + c₅ + c₆ = c₇ 


(*) if문에서 참이면 (4)~(6)을 실행하고, 거짓이면 실행하지 않음.
    상한(upper bound) 실행시간 복잡도를 분석하고 있기 때문에
    최악의 경우, 즉 더 오래 걸리는 경우를 분석함
(3)+(4)~(6):

  (3) T₃(n) = c₃
  (4)~(6): c₇

  T₃(n) + (T₄(n)+T₅(n)+T₆(n)) = c₃ + c₇ = c
  

(1): T₁ = Σ_{i=1,n-1}  T₂(i)

(2): T₂ = Σ_{j=n,i+1} T₃+T₄+T₅+T₆
        = Σ_{j=n,i+1} c
	= (n-i) × c

따라서,
(1): T₁ = Σ_{i=1,n}  (T₂)(i)
        = Σ_{i=1,n}  ( c(n-i) )
	= c(n-1) + c(n-2) + c(n-3) + ... + c×1 + c×0
	= c × (1부터 n-1까지 합) !!!
	= c x (n-1)(n)/2
	= c/2 n² - c/2 n

정리하자면, 함수 bubble의 실행시간 T(n) = c/2 n² - c/2 n    (cf. n: 입력 배열의 크기)

          T(n) = c/2 n² - c/2 n ∈ O(n²) !!!


실제 프로그램의 실행시간 복잡도 분석 사례2

function fact( n:integer )  integer;
 begin
    if n ≤ 1 then
      return 1;
    else
       return n * fact(n-1);
 end


(연습문제)

  - fact의 실행시간 T(n)을 구하시오.   (cf. n은 인자 n. fact(3) ===> n==3!!)
  - T(n) ∈ O( ???  ) 인지 구하시오.

 T(n) =  c₁               if n≤1
         T(n-1) + c₂      if n>1


 (cf. 재귀함수이다보니까 시간 함수도 재귀적형태 (recurrence equations))

 T(n) =             T(n-1)      + c₂
      = (      T(n-2)   + c₂ )  + c₂
      = ( T(n-3) + c₂ ) + c₂ )  + c₂
        ...
      = T(1) + c₂ + ... + c₂
      = c₁ + c₂(n-1)
      = c₂n + c₁ - c₂    ∈ O( n )

  ==>  재귀적형태의 시간 함수를
       닫힌형태(closed form)의 시간 함수로 유도!

  ==> 일반적으로 이렇게 유도하는 방법이 어려울 수 있음.

https://github.com/kwanghoon/datastructure
 - intro/MEMO_intro.txt


(연습문제)
  - 하노이 타워 프로그램의 실행시간 복잡도를 분석하시오!


=====================================================

1장, 2장, 3장 강의 완료!!!


=================
자료구조의 주요 주제
=================

(1)
 - 리스트
 - 트리
 - 그래프

(2)
 - 정렬과 탐색

(3)
 - 스택, 큐, 해쉬 
=================


4장 스택

스택의 정의 (by 추상데이터타입-ADT)

 - is_empty() : 스택이 비어있나요? 예(1), 아니오(0) 
 - is_full()  : 스택이 모두 차있나요?
 - push(원소) : 스택에 원소를 추가
 - 원소 <- pop() : 스택에서 원소를 빼오기
 - peek() : 스택top의 원소를 읽어오기 (pop은 하지 않고)


스택
 - 한쪽으로만 넣고 빼는 구조
 - LIFO (last-in fist-out) 후입 선출 (나중에 넣은 원소를 먼저 꺼낸다.)

 - history를 가지고 있는 구조

스택을 사용하는 Pseudo code


(1) 입력한 원소의 순서를 뒤집기 (reverse)  (참고: 교재 프로그램 4.1, P.110~111)

      입력: 예를 들어, 5, 2, 8, 7, 9 
      출력: 예를 들어, 9, 7, 8, 2, 5 

      알고리즘:

       1.  입력이 끝날때까지 반복
            1-1. 입력 받기
            1-2. 입력 받은 숫자를 스택에 push

       2.  스택이 완전히 빌 때까지 반복
            2-1. 스택에서 pop한 다음 그 원소를 출력 


stack <- []

// 입력 시작

  push(5)

stack <- [5]

  push(2)

stack <- [2, 5]    // 왼쪽이 top!!!

  push(8)
  
stack <- [8, 2, 5]    // 왼쪽이 top!!!

  push(7)

stack <- [7, 8, 2, 5]    // 왼쪽이 top!!!

  push(9)

stack <- [9, 7, 8, 2, 5]    // 왼쪽이 top!!!

// 입력 끝

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9

stack <- [7, 8, 2, 5]

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9 7

stack <- [8, 2, 5]

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9 7 8

stack <- [2, 5]

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9 7 8 2

stack <- [5]

 is_empty()   // false!!!

 print(  pop() )

// 출력: 9 7 8 2 5

stack <- []

 is_empty()   // true!!!


(2) 괄호 매칭 검사하기! (참고: 교재 P119~)


 [ ] : 대괄호
 { } : 중괄호
 ( ) : 소괄호


 [ ( ] )   ===> (X)
 [ ( ) ]   ===> (O)


 예시
   입력: '[', '(', ']', ')'  ===> 출력: X
   입력: '[', '(', ')', ']'  ===> 출력: O


 알고리즘:

  입력: '[', '(', '{', ']', ')', '}' 6개의 문자들로 이뤄진 임의의 문자열!
  출력: 괄호 매칭 검사 결과 - O, X  
      
  1.  입력이 끝날때까지 반복
      1-1. 입력 받기
      1-2. 입력이 열린 괄호이면 스택에 push   [, {, ( 중 하나
           입력이 닫힌 괄호이면
              스택이 비어있으면, X!!
	      
	      스택이 비어있지 않으면,
                 입력이 ]이면
		     스택 top이 [이면, pop()
	             스택 top이 [이 아니면 X!!
			  
                 입력이 }이면
                     스택 top이 {이면, pop()
                     스택 top이 {이 아니면, X!!
		     
                 입력이 )이면
	             스택 top이 (이면, pop()
                     스택 top이 (이 아니면, X!!


[연습문제]
 위 알고리즘에서 고려하지 않은 빠진 경우???
 ==> 정답 진성호!!!

   stack <- [ '(', ...  ]
   입력 ')'


   stack <- [ '(', ...  ]
   입력 ']'


(3) 후위표기식을 (스택을 사용하여) 계산 (P.124)


후위표기식(postfix) 예: 8 2 / 3 - 3 2 * +

- 진성호

후위표기식 계산 알고리즘

 입력: 후위표기식 
 출력: 계산 결과값
 절차:

  1. 입력이 끝날 때까지 반복
      입력 받기
        입력이 숫자이면 (피연산자이면)
	  push(입력)
	  
	입력이 연산자이면 (+, -, *, /)
	  두번째 피연산자 <- pop() // 오류: 첫번째 피연산자 <- pop()
	  첫번째 피연산자 <- pop() // 오류: 두번째 피연산자 <- pop()
	  
	  첫번째 피연산자 (연산) 두번째 피연산자를 계산하여 그 결과를 얻음
	  
	  push( 결과 )

  2. 스택 top에 계산 결과를 peek()해서 출력


(연습문제)
  - 위의 알고리즘에서 스택과 관련한 미묘한 오류가 있습니다. 무엇일까요?

이현기!

  - (Skip) 중위 표기수식을 후위표기 수식으로 바꾸는 방법 ==> 나중에 tree를 배운 다음

(4) 함수 호출에서 돌아갈(return) 위치를 알기 위해서 스택을 사용합니다.

함수호출과 리턴
 - 프로그램을 시작하기 전에는 비어있는 스택
 
 - 함수를 호출할 때마다 돌아올 주소를 스택에 push()
 
 - return문으로 돌아올 때 스택 top에 있는 주소로 돌아갑니다.
   동시에 pop()을 합니다.

// stack0: empty!!
// main을 호출

 main() {     // stack1: [ 운영체제 주소 ] 

   ...
              // stack2: [ L1, 운영체제 주소 ]
   f();      

 L1: // 라벨
              // stack3: [ 운영체제 주소 ]

   ...

              // stack4: [L2,  운영체제 주소 ]
   f();

 L2:  // 라벨
              // stack5: [ 운영체제 주소 ]

   ...

 }

 f() {

   ...

  return;  // Q. L1과 L2 중 어느 곳으로 돌아갈까요?
           // A. stack2의 경우 스택 top은 L1 !! 따라서 L1으로 돌아갑니다. 물론 pop()도 하고.!
           //    stack4의 경우 스택 top은 L2 !! 따라서 L2로 돌아갑니다. 물론 pop()도 하고.!
 }

[연습문제] 함수 호출을 goto문과 스택을 사용해서 흉내내보시라!

int fib(int n) {

L1:
    if ( n==1 || n==2 ) return 1;
    else {
    	 int a, b;

         a = fib(n-1);
L2:

	 b = fib(n-2);
L3:

         return a+b;
    }
}

===> Goto문과 스택을 사용해서 rewriting 해보세요 !
     함수 호출을 사용하면 안됨!
     점프하고 싶은/필요한 위치에 마음대로 라벨을 추가하세요. 
     필요한 코드는 추가하셔도 됩니다.


(5) 미로 탐색 문제 (P.135, Sec.4.6)

 스택을 이용해서 체계적으로 미로를 탐색하는 알고리즘
 (쳬계적 ==> 이미 지나간 길을 반복해서 또 지나가지 않는다!
       ==> 그러려면 지나온 길을 기억해야지요!
       ==> 그래서 스택이 유용합니다.


 현재 위치에서 갈 수 있는 방향, 동/서/남/북

  - 동/서/남/북 중에서 블록을 막힌 길은 안간다
  - 동/서/남/북 중에서 내가 방금 전에 온 방향을 거슬러 올라가지 않는다!
  - 그리고 남은 모든 방향들을 가본다! (기본적인 아이디어)

  알고리즘
    입력: 미로, 시작 위치(x1,y1), 끝 위치(x2,y2)
    출력: 미로 탐색 길
    절차:

      현재 위치 <- (x1, y1)
      스택 <- empty stack

  1.  현재 위치일 끝 위치(x2, y2)가 될 때까지 반복

    1-1 현재 위치에서 가능한 방향
       1-1-1 동:  블록으로 막혀있거나 방금 전에 온 위치(스택 top)이면 skip
                그렇지 않으면 현재 위치를 push()
	        현재 위치를 동쪽으로 이동  (x를 1증가!)
       1-1-2 서:  블록으로 막혀있거나 방금 전에 온 위치(스택 top)이면 skip
                그렇지 않으면 현재 위치를 push()
	        현재 위치를 서쪽으로 이동  (x를 1감소!)
       
       1-1-3 남:  블록으로 막혀있거나 방금 전에 온 위치(스택 top)이면 skip
                그렇지 않으면 현재 위치를 push()
	        현재 위치를 남쪽으로 이동  (y를 1증가!)
		
       1-1-4 북:  블록으로 막혀있거나 방금 전에 온 위치(스택 top)이면 skip
                그렇지 않으면 현재 위치를 push()
	        현재 위치를 남쪽으로 이동  (y를 1감소!)
		
    1-2
        현재 위치를 스택 top에 저장된 위치로 설정. 스택을 pop().
     
[연습문제]
 - 현재 위치에서 끝 위치까지 길이 없는 미로가 입력으로 들어왔을 때
   위 알고리즘은 어떤 방식으로 결과를 낼까요?

   이 문제를 해결하려면 어떻게 알고리즘을 수정해야할까요?



