
리스트(List)

6장 연결 리스트 1
7장 연결 리스트 2

연결 리스트(linked list)

(참고: 교재 그림 6-2)

 list -> addr3

 addr1: (b, addr2)
 addr2: (c, NULL)
 addr3: (a, addr1)


배열 vs. 연결 리스트

               크기 조정      원소 접근
 -----------+---------------------------
 - 배열      |  어렵다          빠르다 O(1)
 -----------+------------------------
 - 연결 리스트|   쉽다           느리다 O(n)
 -----------+--------------------------
                            (n번째 원소)


연결 리스트 종류

 - 단순 연결 리스트
   : 각 셀에 다음 셀을 가리키는 주소를 포함
   : 마지막 셀의 다음 주소는 NULL
   
 - 원형 연결 리스트
   : 리스트의 맨 마지막 셀의 다음 주소가
     NULL이 아니라 맨 처음 셀의 주소를 가리킴

 - 이중 연결 리스트
   : 각 셀에 다음 셀을 가리키는 주소와
            이전 셀을 가리키는 주소를 포함.

 list -> addr3

 addr1: (addr3, b, addr2)  // (prev, item, next)
 addr2: (addr1, c, NULL)
 addr3: (NULL, a, addr1)

cf. 이중 연결 리스트이면서 원형 연결 리스트

 list -> addr3

 addr1: (addr3, b, addr2)  // (prev, item, next)
 addr2: (addr1, c, addr3)
 addr3: (addr2, a, addr1)


E.g.,

 - head -> (10, ) -> (40, ) -> (30, NULL )

연결 리스트(linked list)의 ADT  (Sec. 6.5, P.190)

 - insert_first(head, value)
 
   : head가 가리키는 리스트의 맨 앞에
     value를 추가해서 새로운 리스트를 만들어 리턴

   : Ex) insert_first( head, 50 ) 

                   head
         (50, ) -> (10, ) -> (40, ) -> (30, NULL )

     p <- (???,???);  // value를 포함한 새로운 노드를 만듬
     p->data <- 50;   // (50, ???)
     p->link <- head; // (50, head)
     head <- p;
     return head; 

   Q. head가 비어있는 리스트라고 가정할 때 insert_first가 기대하는대로 동작할까요?

 - insert( head, pre, value )

   : head가 가리키는 리스트에서
     pre가 가리키는 원소 바로 다음에
     value를 추가해서 새로운 리스트를 만들어 리턴

   : Ex) insert( head, pre, 50 )

                              pre
           head -> (10, ) -> (40, ) -> (30, NULL )

         ==(insert)==> 

           (10, ) -> (40, ) -> (50, ) -> (30, NULL )

     -----------------------------------------------------
                              pre
           head -> (10, ) -> (40, ) -> (30, NULL )

     p <- (???, ???)  // 새로 할당 (???, ???)
     p->data = value; // (value, ???)
     p->link = pre->link; (value, pre->link)

                              pre
           head -> (10, ) -> (40, )       -> (30, NULL )
                                   (50, ) ->
     pre->link = p;

           (10, ) -> (40, ) -> (50, ) -> (30, NULL )

     return head; 

 - delete ( head, pre )
    : head가 가리키는 리스트에서
      pre가 가리키는 원소 바로 다음 원소를 삭제

    cf. 원소 <===> 노드(node)

   : Ex) delete( head, pre )

                              pre
           head -> (10, ) -> (40, ) -> (30, NULL )

         ==(delete)==> 

           (10, ) -> (40, NULL)
	   

     -----------------------------------------------------

                              pre
           head -> (10, ) -> (40, ) -> (30, NULL )

      p = pre->link;   // delete해야할 노드 p
      pre->link = pre->link->link;
      free(p);  // 메모리 사용을 해제
      return head; 

   Q. head가 비어있는 리스트일 때 delete를 사용해도 되나요?
   
      head <- NULL
      pre <- NULL
      delete( head, pre )
      
   Q. head가 가리키는 리스트의 원소가 1개라고 할때, delete를 사용해도 되나요?

      head <- (123, NULL)
      pre <- head
      delete ( head, pre )

   Q. head가 가리키는 리스트의 원소가 2개라고 할때, delete를 사용해도 되나요?

      (1)
              pre
      head <- (123, ) -> (456, NULL) 
      delete ( head, pre )

      (2)
                          pre
      head <- (123, ) -> (456, NULL) 
      delete ( head, pre )

 - print_list( head )

    : head가 가리키는 리스트가 비어있거나 비어있지 않거나!

      p <- head;
      반복: 
        if (p가 가리키는 리스트가 비어있으면)
          return;
        else { // p가 가리키는 리스트에 원소가 있다!
          print ( p->data )
          p <- p->link; 
        }

// 박상현, 황우성, 이수현, 오채린, 진성호, 이혜은, 김명은


LAB
 - 두 개의 리스트를 하나로 합치는 함수 작성
 - 리스트를 뒤집는 함수 작성


(*) 다항식을 연결리스트로 표현하는 방법


